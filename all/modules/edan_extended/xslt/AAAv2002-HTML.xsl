<!-- stephboxfolder generated by Steph 6/05 using Loren's stylesheet generated by Loren 1/31/02 from E AD Cookbook Style 2 and Michael Fox's changes to the container list Version 0.9   2000 July 22; incorporating changes attempting to accomodate EAD Cookbook v. 2  -->
<!--  This stylesheet generates Style 2 and Michael Fox's addition for boxes and folders which has a Table of Contents in an HTML table cell along the left side of the screen. It may be used when an HTML frame is not desired.  -->
<xsl:stylesheet version="2.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform" xmlns:ead="urn:isbn:1-931666-22-9"
  xmlns:xs="http://www.w3.org/2001/XMLSchema" xmlns="http://www.w3.org/1999/xhtml" xmlns:fn="http://www.w3.org/2005/02/xpath-functions"
  xmlns:xdt="http://www.w3.org/2005/02/xpath-datatypes" xmlns:ns2="http://www.w3.org/1999/xlink">
			
<xsl:output method="xml" indent="yes" encoding="UTF-8"/>
<xsl:strip-space elements="*"/>

<!-- Creates the body of the finding aid.-->
<xsl:template match="/*">
	<html>
		<head>
			<xsl:call-template name="head"/>
		</head>
		<body>
			<table width="100%" cellpadding="5">
				<tr>
					<td width="20%" valign="top"><xsl:call-template name="toc"/></td>
					<td width="80%" valign="top">
						<!-- The ead header contains the cover page information -->
						<xsl:call-template name="cover"/>
						<xsl:call-template name="archdesc-did"/>
						<xsl:call-template name="archdesc-admininfo"/>
						<xsl:call-template name="archdesc-bioghist"/>
						<xsl:call-template name="archdesc-scopecontent"/>
						<xsl:call-template name="archdesc-control"/>
						<xsl:call-template name="archdesc-arrangement"/>
						<xsl:call-template name="dsc"/>
					</td>
				</tr>
			</table>
		</body>
	</html>
</xsl:template>

	<xsl:template name="head">
		<style> h1, h2, h3, h4 {font-family: arial}</style> 
		<meta http-equiv="content-type" content="text/html; charset=UTF-8" />
		<title>
			<xsl:value-of select="ead:eadheader/ead:filedesc/ead:titlestmt/ead:titleproper" />
		</title>
		<xsl:element name="meta">
			<xsl:attribute name="name">dc.title</xsl:attribute>
			<xsl:attribute name="content"><xsl:value-of select="ead:eadheader/ead:filedesc/ead:titlestmt/ead:titleproper" /></xsl:attribute>
		</xsl:element>
		<xsl:element name="meta">
			<xsl:attribute name="name">dc.author</xsl:attribute>
			<xsl:attribute name="content"><xsl:value-of select="ead:archdesc/ead:did/ead:origination" /></xsl:attribute>
		</xsl:element>
		<xsl:for-each select="//ead:controlaccess/ead:persname | //ead:controlaccess/ead:corpname">
			<xsl:choose>
				<xsl:when test="@encodinganalog='600'">
					<xsl:element name="meta">
						<xsl:attribute name="name">dc.subject</xsl:attribute>
						<xsl:attribute name="content"><xsl:value-of select="." /></xsl:attribute>
					</xsl:element>
				</xsl:when>
				<xsl:when test="@encodinganalog='610'">
					<xsl:element name="meta">
						<xsl:attribute name="name">dc.subject</xsl:attribute>
						<xsl:attribute name="content"><xsl:value-of select="." /></xsl:attribute>
					</xsl:element>
				</xsl:when>
				<xsl:when test="@encodinganalog='611'">
					<xsl:element name="meta">
						<xsl:attribute name="name">dc.subject</xsl:attribute>
						<xsl:attribute name="content"><xsl:value-of select="." /></xsl:attribute>
					</xsl:element>
				</xsl:when>
				<xsl:when test="@encodinganalog='700'">
					<xsl:element name="meta">
						<xsl:attribute name="name">dc.contributor</xsl:attribute>
						<xsl:attribute name="content"><xsl:value-of select="." /></xsl:attribute>
					</xsl:element>
				</xsl:when>
				<xsl:when test="@encodinganalog='710'">
					<xsl:element name="meta">
						<xsl:attribute name="name">dc.contributor</xsl:attribute>
						<xsl:attribute name="content"><xsl:value-of select="." /></xsl:attribute>
					</xsl:element>
				</xsl:when>
				<xsl:when test="@encodinganalog='711'">
					<xsl:element name="meta">
						<xsl:attribute name="name">dc.contributor</xsl:attribute>
						<xsl:attribute name="content"><xsl:value-of select="." /></xsl:attribute>
					</xsl:element>
				</xsl:when>
				<xsl:otherwise>
					<xsl:element name="meta">
						<xsl:attribute name="name">dc.contributor</xsl:attribute>
						<xsl:attribute name="content"><xsl:value-of select="." /></xsl:attribute>
					</xsl:element>
				</xsl:otherwise>
			</xsl:choose>
		</xsl:for-each>
		<xsl:for-each select="//ead:controlaccess/ead:subject">
			<xsl:element name="meta">
				<xsl:attribute name="name">dc.subject</xsl:attribute>
				<xsl:attribute name="content"><xsl:value-of select="." /></xsl:attribute>
			</xsl:element>
		</xsl:for-each>
		<xsl:element name="meta">
			<xsl:attribute name="name">dc.title</xsl:attribute>
			<xsl:attribute name="content"><xsl:value-of select="ead:archdesc/ead:did/ead:unittitle" /></xsl:attribute>
		</xsl:element>
		<xsl:element name="meta">
			<xsl:attribute name="name">dc.type</xsl:attribute>
			<xsl:attribute name="content">text</xsl:attribute>
		</xsl:element>
		<xsl:element name="meta">
			<xsl:attribute name="name">dc.format</xsl:attribute>
			<xsl:attribute name="content">manuscripts</xsl:attribute>
		</xsl:element>
		<xsl:element name="meta">
			<xsl:attribute name="name">dc.format</xsl:attribute>
			<xsl:attribute name="content">finding aids</xsl:attribute>
		</xsl:element>
		<xsl:for-each select="//ead:controlaccess/ead:geogname">
			<xsl:element name="meta">
				<xsl:attribute name="name">dc.coverage</xsl:attribute>
				<xsl:attribute name="content"><xsl:value-of select="." /></xsl:attribute>
			</xsl:element>
		</xsl:for-each>
	</xsl:template>

<xsl:template name="toc">
	<xsl:variable name="file">
		<xsl:value-of select="ead:eadheader/ead:eadid" />
	</xsl:variable>
	<h3>
		TABLE OF CONTENTS
	</h3>
	<br>
	</br>
	<xsl:if test="ead:archdesc/ead:did">
		<p>
			<b>
				<a href="#a1">
					<xsl:value-of select="ead:archdesc/ead:did/ead:head" />
				</a>
			</b>
		</p>
	</xsl:if>
	<xsl:if test="ead:archdesc/ead:acqinfo[string-length(text()|*)!=0] | ead:archdesc/ead:separatedmaterial[string-length(text()|*)!=0] | ead:archdesc/ead:originalsloc[string-length(text()|*)!=0] | ead:archdesc/ead:relatedmaterial[string-length(text()|*)!=0] | ead:archdesc/ead:processinfo[string-length(text()|*)!=0] | ead:archdesc/ead:altformavail[string-length(text()|*)!=0] | ead:archdesc/ead:prefercite[string-length(text()|*)!=0] | ead:archdesc/ead:accessrestrict[string-length(text()|*)!=0] | ead:archdesc/ead:userestrict[string-length(text()|*)!=0] | ead:archdesc/ead:custodialhist[string-length(text()|*)!=0] | ead:archdesc/ead:appraisal[string-length(text()|*)!=0] | ead:archdesc/ead:accruals[string-length(text()|*)!=0]">
		<p>
			<b>
				<a href="#a14">
					<xsl:text>
						Administrative Information
					</xsl:text>
				</a>
			</b>
		</p>
	</xsl:if>
	<xsl:if test="ead:archdesc/ead:bioghist[string-length(text()|*)!=0]">
		<p>
			<b>
				<a href="#a2">
					<xsl:value-of select="ead:archdesc/ead:bioghist/ead:head" />
				</a>
			</b>
		</p>
	</xsl:if>
	<xsl:if test="ead:archdesc/ead:scopecontent[string-length(text()|*)!=0]">
		<p>
			<b>
				<a href="#a3">
					<xsl:value-of select="ead:archdesc/ead:scopecontent/ead:head" />
				</a>
			</b>
		</p>
	</xsl:if>
	<xsl:if test="ead:archdesc/ead:arrangement[string-length(text()|*)!=0]">
		<p>
			<b>
				<a href="#a4">
					<xsl:value-of select="ead:archdesc/ead:arrangement/ead:head" />
				</a>
			</b>
		</p>
	</xsl:if>
	<xsl:if test="ead:archdesc/ead:controlaccess[string-length(text()|*)!=0]">
		<p>
			<b>
				<a href="#a12">
					<xsl:value-of select="ead:archdesc/ead:controlaccess/ead:head" />
				</a>
			</b>
		</p>
	</xsl:if>
	<xsl:if test="ead:archdesc/ead:dsc[string-length(text()|*)!=0]">
		<a href="#a23">
			<p>
				<b>
					<xsl:value-of select="ead:archdesc/ead:dsc/ead:head" />
				</b>
			</p>
		</a>
		<xsl:for-each select="ead:archdesc/ead:dsc/ead:c">
			<p>
				<b>
					<font size="-1">
						<a>
							<xsl:attribute name="href">
								#series
								<xsl:number value="position()" format="1" />
							</xsl:attribute>
							<xsl:choose>
								<xsl:when test="ead:did/ead:unittitle/ead:unitdate">
									<xsl:for-each select="ead:did/ead:unittitle">
										<xsl:apply-templates select="." />
									</xsl:for-each>
								</xsl:when>
								<xsl:otherwise>
									<xsl:apply-templates select="ead:did/ead:unittitle" />
									<xsl:text>
									</xsl:text>
									<xsl:apply-templates select="ead:did/ead:unitdate" />
								</xsl:otherwise>
							</xsl:choose>
						</a>
					</font>
				</b>
			</p>
		</xsl:for-each>
		<xsl:for-each select="//odd">
			<xsl:if test="//odd[string-length(text()|*)!=0]/ead:head">
				<p>
					<b>
						<a href="#{@id}"><xsl:value-of select="ead:head" /></a>
					</b>
				</p>
			</xsl:if>
		</xsl:for-each>
		<xsl:if test="ead:archdesc/ead:otherfindaid[string-length(text()|*)!=0]">
			<p>
				<b>
					<a href="#a8">
						<xsl:value-of select="ead:archdesc/ead:otherfindaid/ead:head" />
					</a>
				</b>
			</p>
		</xsl:if>
		<xsl:if test="ead:archdesc/ead:index[string-length(text()|*)!=0]">
			<p>
				<b>
					<a href="#a9">
						<xsl:value-of select="ead:archdesc/ead:index/ead:head" />
					</a>
				</b>
			</p>
		</xsl:if>
		<xsl:if test="ead:archdesc/ead:bibliography[string-length(text()|*)!=0]">
			<p>
				<b>
					<a href="#a10">
						<xsl:value-of select="ead:archdesc/ead:bibliography/ead:head" />
					</a>
				</b>
			</p>
		</xsl:if>
	</xsl:if>
</xsl:template>

<xsl:template name="cover">
	<xsl:for-each select="ead:eadheader/ead:filedesc/ead:titlestmt">
		<xsl:if test="string-length(ead:titleproper)">
			<h1>
				<xsl:value-of select="ead:titleproper"/>
			</h1>				
		</xsl:if>
		<h2>
			<xsl:value-of select="ead:subtitle"/>
		</h2>
		<h3>
			<xsl:value-of select="ead:author"/>
		</h3>
		<xsl:if test="string-length(ead:sponsor)">
			<h4>
				<xsl:value-of select="ead:sponsor"/>
			</h4>
		</xsl:if>
	</xsl:for-each>
	
	<h5>
		<xsl:value-of select="ead:eadheader/ead:filedesc/ead:publicationstmt/ead:date"/>
	</h5>

	<dl>
		<dt><xsl:value-of select="ead:eadheader/ead:filedesc/ead:publicationstmt/ead:publisher"/></dt>
		<xsl:for-each select="ead:eadheader/ead:filedesc/ead:publicationstmt/ead:address/ead:addressline">
			<dd><xsl:value-of select="."/></dd>
		</xsl:for-each>
	</dl>
	
	<hr/>
</xsl:template>

<!--This template rule formats the top-level did element.-->
<xsl:template name="archdesc-did">
		
	<!--For each element of the did, this template inserts the value of the LABEL attribute or, if none is present, a default value.-->
	<xsl:for-each select="ead:archdesc/ead:did">
		<table width="100%">
			<xsl:if test="ead:origination[string-length(text()|*)!=0]">
				<xsl:for-each select="ead:origination">
					<xsl:choose>
						<xsl:when test="@label">
							<tr>
								<td valign="top">
									<!-- <b><xsl:value-of select="@label"/>:</b> -->
									<b><xsl:text>Creator: </xsl:text></b>
								</td>
								<td>
									<xsl:apply-templates select="."/>
								</td>
							</tr>
						</xsl:when>
						<xsl:otherwise>
							<tr>
								<td valign="top">
									<b><xsl:text>Creator: </xsl:text></b>
								</td>
								<td>
									<xsl:apply-templates select="."/>
								</td>
							</tr>
						</xsl:otherwise>
					</xsl:choose>
				</xsl:for-each>
			</xsl:if>
			
			
			<!-- Tests for and processes various permutations of unittitle and unitdate.-->
			<xsl:for-each select="ead:unittitle">
				<xsl:choose>
					<xsl:when test="@label">
						<tr>
							<td valign="top">
								<b><xsl:value-of select="@label"/></b>
							</td>
							<td>
								<xsl:apply-templates
									select="text() |* [not(self::unitdate)]"/>
							</td>
						</tr>
					</xsl:when>
					<xsl:otherwise>
						<tr>
							<td valign="top">
								<b><xsl:text>Title: </xsl:text></b>
							</td>
							<td>
								<xsl:apply-templates
									select="text() |* [not(self::unitdate)]"/>
							</td>
						</tr>
					</xsl:otherwise>
				</xsl:choose>
			</xsl:for-each>
			
			
			<!-- Processes the unit date if it is not a child of unit title but a child of did, the current context.-->
			<xsl:if test="ead:unitdate">
				<xsl:for-each select="unitdate[string-length(text()|*)!=0]">
					<xsl:choose>
						<xsl:when test="./@label">
							<tr>
								<td valign="top">
									<b><xsl:value-of select="./@label"/></b>
								</td>
								<td>
									<xsl:apply-templates select="."/>
								</td>
							</tr>
						</xsl:when>
						<xsl:otherwise>
							<tr>
								<td valign="top">
									<b><xsl:text>Dates: </xsl:text></b>
								</td>
								<td>
									<xsl:apply-templates select="."/>
								</td>
							</tr>
						</xsl:otherwise>
					</xsl:choose>
				</xsl:for-each>
			</xsl:if>
			
			<xsl:if test="ead:abstract[string-length(text()|*)!=0]">
				<xsl:choose>
					<xsl:when test="@label">
						<tr>
							<td valign="top">
								<b><xsl:value-of select="@label"/></b>
							</td>
							<td>
								<xsl:apply-templates select="ead:abstract"/>
							</td>
						</tr>
					</xsl:when>
					<xsl:otherwise>
						<tr>
							<td valign="top">
								<b><xsl:text>Abstract: </xsl:text></b>
							</td>
							<td>
								<xsl:apply-templates select="ead:abstract"/>
							</td>
						</tr>
					</xsl:otherwise>
				</xsl:choose>
			</xsl:if>
			
			<xsl:if test="ead:physdesc[string-length(text()|*)!=0]">
				<xsl:choose>
					<xsl:when test="@label">
						<tr>
							<td valign="top">
								<b><xsl:value-of select="@label"/></b>
							</td>
							<td>
								<xsl:apply-templates select="ead:physdesc"/>
							</td>
						</tr>
					</xsl:when>
					
					<xsl:otherwise>
						<tr>
							<td valign="top">
								<b><xsl:text>Extent: </xsl:text></b>
							</td>
							<td>
								<xsl:apply-templates select="ead:physdesc"/>
							</td>
						</tr>
					</xsl:otherwise>
				</xsl:choose>
			</xsl:if>
			
			<xsl:if test="ead:langmaterial/ead:language/@langcode!=''">
				<tr>
					<td valign="top">
						<b><xsl:text>Language: </xsl:text></b>
					</td>
					<td>
						<xsl:apply-templates select="ead:langmaterial/ead:language/@langcode"/>
					</td>
				</tr>
			</xsl:if>
			
			<xsl:if test="ead:unitid[string-length(text()|*)!=0]">
				<xsl:choose>
					<xsl:when test="@label">
						<tr>
							<td valign="top">
								<b><xsl:value-of select="@label"/></b>
							</td>
							<td>
								<xsl:apply-templates select="ead:unitid"/>
							</td>
						</tr>
					</xsl:when>
					
					<xsl:otherwise>
						<tr>
							<td valign="top">
								<b><xsl:text>Unit ID: </xsl:text></b>
							</td>
							<td>
								<xsl:apply-templates select="ead:unitid"/>
							</td>
						</tr>
					</xsl:otherwise>
				</xsl:choose>
			</xsl:if>
			
			<xsl:if test="ead:physloc[string-length(text()|*)!=0]">
				<xsl:choose>
					<xsl:when test="@label">
						<tr>
							<td valign="top">
								<b><xsl:value-of select="@label"/></b>
							</td>
							<td>
								<xsl:apply-templates select="ead:physloc"/>
							</td>
						</tr>
					</xsl:when>
					
					<xsl:otherwise>
						<tr>
							<td valign="top">
								<b><xsl:text>Location: </xsl:text></b>
							</td>
							<td>
								<xsl:apply-templates select="ead:physloc"/>
							</td>
						</tr>
					</xsl:otherwise>
				</xsl:choose>
			</xsl:if>
			
			<xsl:if test="ead:note[string-length(text()|*)!=0]">
				<xsl:for-each select="note">
					<xsl:choose>
						<xsl:when test="@label">
							<tr>
								<td valign="top">
									<b><xsl:value-of select="@label"/></b>
								</td>
							</tr>
							<xsl:for-each select="ead:p">
								<tr>
									<td valign="top">
										<xsl:apply-templates/>
									</td>
								</tr>
							</xsl:for-each>
						</xsl:when>
						
						<xsl:otherwise>
							<tr>
								<td valign="top">
									<b>Location:</b>
								</td>
								<td>
									<xsl:apply-templates select="ead:note"/>
								</td>
							</tr>
						</xsl:otherwise>
					</xsl:choose>
				</xsl:for-each>
			</xsl:if>
			
		</table>
		<hr/>
		
	</xsl:for-each>
</xsl:template>

<!-- Administrative Information -->
<!--This template rule formats a top-level admininfo element.-->
<xsl:template name="archdesc-admininfo">
	<xsl:if
		test="ead:archdesc/ead:acqinfo[string-length(text()|*)!=0] | ead:archdesc/ead:separatedmaterial[string-length(text()|*)!=0] | ead:archdesc/ead:originalsloc[string-length(text()|*)!=0] | ead:archdesc/ead:relatedmaterial[string-length(text()|*)!=0] | ead:archdesc/ead:altformavail[string-length(text()|*)!=0] | ead:archdesc/ead:processinfo[string-length(text()|*)!=0] | ead:archdesc/ead:prefercite[string-length(text()|*)!=0] | ead:archdesc/ead:custodialhist[string-length(text()|*)!=0] | ead:archdesc/ead:appraisal[string-length(text()|*)!=0] | ead:archdesc/ead:accruals[string-length(text()|*)!=0]">
		<h3>
			<a name="a14">
				<b><xsl:text>Administrative Information</xsl:text></b>
			</a>
		</h3>
		<xsl:for-each select="ead:archdesc/ead:acqinfo">
			<h4>
				<b><xsl:value-of select="ead:head"/></b>
			</h4>
			<xsl:for-each select="ead:p">
				<p>
					<xsl:apply-templates select="."/>
				</p>
			</xsl:for-each>
		</xsl:for-each>
		<xsl:for-each select="ead:archdesc/ead:separatedmaterial">
			<h4>
				<b><xsl:value-of select="ead:head"/></b>
			</h4>
			<xsl:for-each select="ead:p">
				<p>
					<xsl:apply-templates select="."/>
				</p>
			</xsl:for-each>			
		</xsl:for-each>
		<xsl:for-each select="ead:archdesc/ead:originalsloc">
			<h4>
				<b><xsl:value-of select="ead:head"/></b>
			</h4>
			<xsl:for-each select="ead:p">
				<p>
					<xsl:apply-templates select="."/>
				</p>
			</xsl:for-each>						
		</xsl:for-each>
		<xsl:for-each select="ead:archdesc/ead:relatedmaterial">
			<h4>
				<b><xsl:value-of select="ead:head"/></b>
			</h4>
			<xsl:for-each select="ead:p">
				<p>
					<xsl:apply-templates select="."/>
				</p>
			</xsl:for-each>						
		</xsl:for-each>
		<xsl:for-each select="ead:archdesc/ead:altformavail">
			<h4>
				<b><xsl:value-of select="ead:head"/></b>
			</h4>
			<xsl:for-each select="ead:p">
				<p>
					<xsl:apply-templates select="."/>
				</p>
			</xsl:for-each>						
		</xsl:for-each>
		<xsl:for-each select="ead:archdesc/ead:processinfo">
			<h4>
				<b><xsl:value-of select="ead:head"/></b>
			</h4>
			<xsl:for-each select="ead:p">
				<p>
					<xsl:apply-templates select="."/>
				</p>
			</xsl:for-each>						
		</xsl:for-each>
		<xsl:for-each select="ead:archdesc/ead:prefercite">
			<h4>
				<b><xsl:value-of select="ead:head"/></b>
			</h4>
			<xsl:for-each select="ead:p">
				<p>
					<xsl:apply-templates select="."/>
				</p>
			</xsl:for-each>						
		</xsl:for-each>
		<xsl:for-each select="ead:archdesc/ead:accessrestrict">
			<h4>
				<b><xsl:value-of select="ead:head"/></b>
			</h4>
			<xsl:for-each select="ead:p">
				<p>
					<xsl:apply-templates select="."/>
				</p>
			</xsl:for-each>						
		</xsl:for-each>
		<xsl:for-each select="ead:archdesc/ead:userestrict">
			<h4>
				<b><xsl:value-of select="ead:head"/></b>
			</h4>
			<xsl:for-each select="ead:p">
				<p>
					<xsl:apply-templates select="."/>
				</p>
			</xsl:for-each>						
		</xsl:for-each>
		<xsl:for-each select="ead:archdesc/ead:accruals">
			<h4>
				<b><xsl:value-of select="ead:head"/></b>
			</h4>
			<xsl:for-each select="ead:p">
				<p>
					<xsl:apply-templates select="."/>
				</p>
			</xsl:for-each>						
		</xsl:for-each>
		<p><a href="#a0">Return to the Table of Contents</a></p>
		<hr/>
	</xsl:if>
</xsl:template>

<!-- Biographical Note -->
<!-- This template rule formats the top-level bioghist element -->
<xsl:template name="archdesc-bioghist">		
	<xsl:if test="ead:archdesc/ead:bioghist[string-length(text()|*)!=0]">
		<xsl:for-each select="ead:archdesc/ead:bioghist">
			<xsl:apply-templates/>
			<p><a href="#a0">Return to the Table of Contents</a></p>
			<hr/>
		</xsl:for-each>
	</xsl:if>
</xsl:template>

<xsl:template match="ead:archdesc/ead:bioghist/ead:head">
	<h3 class="bioghist"><a name="a2"><xsl:apply-templates/></a></h3>
</xsl:template>

<xsl:template match="ead:archdesc/ead:bioghist/ead:p">
	<p><xsl:apply-templates/></p>
</xsl:template>

<xsl:template match="ead:archdesc/ead:bioghist/ead:chronlist">
	<xsl:apply-templates/>
</xsl:template>

<!-- Scope Content -->
<!--This template rule formats the scopecontent element.-->
<xsl:template name="archdesc-scopecontent">
	<xsl:if test="ead:archdesc/ead:scopecontent[string-length(text()|*)!=0]">
		<xsl:for-each select="ead:archdesc/ead:scopecontent">
			<p><xsl:apply-templates/></p>
		</xsl:for-each>
		<p><a href="#a0">Return to the Table of Contents</a></p>
		<hr/>
	</xsl:if>
</xsl:template>

<xsl:template match="ead:archdesc/ead:scopecontent/ead:head">
	<h3><a name="a3"><xsl:apply-templates/></a></h3>
</xsl:template>

<xsl:template match="ead:archdesc/ead:scopecontent/ead:p">
	<p><xsl:apply-templates/></p>
</xsl:template>

<!-- Names and Subjects -->
<xsl:template name="archdesc-control">
	<xsl:if test="ead:archdesc/ead:controlaccess[string-length(text()|*)!=0]">
		<xsl:for-each select="ead:archdesc/ead:controlaccess">
			<h4>Names and Subjects</h4>
			<ul>
				<xsl:for-each select="ead:subject | ead:corpname | ead:persname | ead:famname| ead:genreform | ead:title | ead:geogname | ead:occupation">
					<xsl:sort select="."/>
					<li>
						<xsl:apply-templates select="."/>
					</li>
				</xsl:for-each>
			</ul>
		</xsl:for-each>
		<p><a href="#a0">Return to the Table of Contents</a></p>
		<hr/>
	</xsl:if>
</xsl:template>

<!-- ARRANGEMENT WITHIN A SERIES -->
<!-- This formats an arrangement list embedded within a series -->
<xsl:template name="subseries-list">
	<xsl:for-each select="ead:arrangement/ead:p">
		<xsl:if test="text()[not(self::list)]">
			<p><xsl:apply-templates select="."/></p>
		</xsl:if>
	</xsl:for-each>
	
	<xsl:variable name="seriesAnchorPrefix">
		<xsl:call-template name="generateAnchorString" />
	</xsl:variable>
	
	<xsl:if test="ead:arrangement/ead:p/ead:list[string-length(text()|*)!=0]">
		<ul>
			<xsl:for-each select="ead:arrangement/ead:p/ead:list">
				<xsl:for-each select="ead:item">
					<li><a><xsl:attribute name="href">#<xsl:value-of select="$seriesAnchorPrefix" />_<xsl:number/></xsl:attribute><xsl:apply-templates select="."/></a></li>
				</xsl:for-each>
			</xsl:for-each>
		</ul>
	</xsl:if>

</xsl:template>

<!-- MAIN SERIES ARRANGEMENT -->
<!--This template rule formats the arrangement element.-->
<xsl:template name="archdesc-arrangement">
	<xsl:if test="ead:archdesc/ead:arrangement[string-length(text()|*)!=0]">

		<xsl:for-each select="ead:archdesc/ead:arrangement">

			<h3><a name="a4"><xsl:apply-templates select="ead:head"/></a></h3>
	
			<xsl:for-each select="ead:p">
				<p><xsl:apply-templates select="."/></p>
			</xsl:for-each>
				
			<xsl:for-each select="ead:list">
				<p><xsl:apply-templates select="ead:head"/></p>
				<ul>
					<xsl:for-each select="ead:item">
						<li><a><xsl:attribute name="href">#series<xsl:number/></xsl:attribute><xsl:apply-templates select="."/></a></li>
					</xsl:for-each>						
				</ul>
			</xsl:for-each>

		</xsl:for-each>

		<p><a href="#a0">Return to the Table of Contents</a></p>
		<hr/>

	</xsl:if>
</xsl:template>

<!-- This named template is a wrapper for the entire ead:archdesc/ead:dsc block -->
<xsl:template name="dsc">
	<xsl:for-each select="ead:archdesc/ead:dsc">
		<xsl:apply-templates select="ead:c"/>
	</xsl:for-each>
</xsl:template>

<xsl:template name="unittitle-stuff">
	<!--This named template defines the processing of unittitle and unitdates in a way that
	is applicable at all component levels. It is invoked throughout the following templates.
	Unitdates may be the children either of unittitle or did. This templates sorts those options
	out. It also includes conditional processing to handle situations where unitdate elements are
	included in the markup but empty of PCDATA content.-->
	<xsl:choose>
	<!--When unitdate is a child of unittitle.-->
	  <xsl:when test="ead:unittitle/ead:unitdate">
	    <xsl:for-each select="ead:unittitle">
	      <!--Inserts the text of unittitle and any children other than unitdate.-->
	      <xsl:apply-templates select="text()|*[not(self::unitdate)]"/>
	        <!--Tests to see if the unitdate has content and adds it and separating space
	        if it does.-->
	        <xsl:if test="string-length(./ead:unitdate)!=0">
						<xsl:text>
						</xsl:text>
	          <xsl:apply-templates select="./ead:unitdate"/>
	        </xsl:if>
	    </xsl:for-each>
	  </xsl:when>
		<!--When unitdate is a child of did.-->
		<xsl:otherwise>
		  <xsl:apply-templates select="ead:unittitle"/>
		  <xsl:if test="string-length(ead:unitdate)!=0">
						<xsl:text>
						</xsl:text>
		    <xsl:apply-templates select="ead:unitdate"/>
		  </xsl:if>
		</xsl:otherwise>
	</xsl:choose>
</xsl:template>

<!-- ====================================================================== -->
<!-- == Single Series Details ============================================= -->
<!-- ====================================================================== -->

<!-- Every component level will be treated the same. This allows for minimizing code-repetition, not creating out of memory problems, and faster execution -->
<xsl:template match="ead:c">

	<!-- The indent level is passed in from the previous component in the hierarchy. That way, we get the correct visual nesting of folder headings based on the nesting of components -->
	<xsl:param name="indentLevel" select="0" />
	
	<!-- Check to see if this component is a series -->
	<xsl:variable name="series">
		<xsl:call-template name="checkForSeries">
			<xsl:with-param name="currentComponent" select="." />
		</xsl:call-template>
	</xsl:variable>
	
	<!-- The component will be displayed either as a series or a container -->
	<xsl:choose>
		<!-- If this component is a series, display it as a series -->
		<xsl:when test="$series='true'">
			<xsl:call-template name="display-series">
				<xsl:with-param name="currentComponent" select="." />
			</xsl:call-template>	
		</xsl:when>
		<!-- Otherwise, simply display the component as a container.  All non-series components (folder groupings, folders, items) get displayed the same way -->
		<xsl:otherwise>
			<xsl:comment>GOT HERE! (Single Series Details - template match="ead:c")</xsl:comment>
		</xsl:otherwise>
	</xsl:choose>

	<!-- This determines the indent level to pass on to children of this component -->
	<xsl:variable name="nextIndentLevel">
		<xsl:choose>
			<xsl:when test="$series != 'true'">
				<xsl:value-of select="number($indentLevel + 1)" />
			</xsl:when>
			<xsl:otherwise>
				<xsl:value-of select="0" />
			</xsl:otherwise>
		</xsl:choose>
	</xsl:variable>
	
	<xsl:apply-templates select="ead:c">
		<xsl:with-param name="indentLevel" select="$nextIndentLevel" />
	</xsl:apply-templates>
</xsl:template>

<!-- 
	Any component with a level or otherlevel attribute becomes a series.
	
	This has a standard display
-->
<xsl:template name="display-series">

	<xsl:param name="currentComponent" />
	
		<xsl:choose>
			<!-- If at the file level, build-out an <h4> element -->
			<xsl:when test="$currentComponent/@level='file'">
				<h4>
					<!-- Remove http://edan.si.edu/slideshow/slideshowViewer.htm?damspath= -->
					<xsl:for-each select="$currentComponent/ead:dao">
						<xsl:variable name="damspath">
								<xsl:call-template name="replace-string">
								  <xsl:with-param name="text" select="$currentComponent/ead:dao/@ns2:href"/>
								  <xsl:with-param name="replace" select="'http://edan.si.edu/slideshow/slideshowViewer.htm?damspath='" />
								  <xsl:with-param name="with" select="''"/>
								</xsl:call-template>
						</xsl:variable>
						<xsl:variable name="damspathCount"><xsl:number/></xsl:variable>
						<!-- Add the data attribute to the <h4> element -->
						<xsl:attribute name="data-damspath-{$damspathCount}"><xsl:value-of select="$damspath" /></xsl:attribute>
						<xsl:attribute name="data-box"><xsl:value-of select="$currentComponent/ead:did/ead:container[@type='Box']" /></xsl:attribute>
						<xsl:attribute name="data-box-id"><xsl:value-of select="$currentComponent/ead:did/ead:container[@type='Box']/@id" /></xsl:attribute>
						<xsl:attribute name="data-folder"><xsl:value-of select="$currentComponent/ead:did/ead:container[@type='Folder']" /></xsl:attribute>
						<xsl:attribute name="data-folder-parent-id"><xsl:value-of select="$currentComponent/ead:did/ead:container[@type='Folder']/@parent" /></xsl:attribute>
					</xsl:for-each>

					<xsl:for-each select="$currentComponent/ead:did">
			      <xsl:call-template name="unittitle-stuff"/>
			    </xsl:for-each>
			    <!-- Adding text here, otherwise, there isn't any space between the title and the physical description -->
			    <xsl:text> </xsl:text>
			    <xsl:apply-templates select="$currentComponent/ead:did/ead:physdesc"/>
				</h4>
			</xsl:when>
			<!-- If at the series or subseries level, build-out an <h3> element -->
			<xsl:otherwise>

				<h3>
					<!-- Series "anchor" string for the named anchor that users will follow to this series -->
					<xsl:variable name="seriesAnchorPrefix">
						<xsl:call-template name="generateAnchorString" />
					</xsl:variable>

					<!-- Subseries "anchor" string string for the named anchor that users will follow to this series -->
					<xsl:variable name="subseriesAnchorPrefix">
						<xsl:choose>
							<xsl:when test="$currentComponent/@level='subseries'">
								<!-- String replace on unitid - not the best way, need regex -->
								<xsl:variable name="unitId">
									<xsl:value-of select="$currentComponent/ead:did/ead:unitid" />
								</xsl:variable>
								<xsl:variable name="unitIdCount">
									<xsl:call-template name="replace-string">
									  <xsl:with-param name="text" select="$unitId"/>
									  <xsl:with-param name="replace" select="'2.'" />
									  <xsl:with-param name="with" select="''"/>
									</xsl:call-template>
									<!-- <xsl:value-of select="replace($unitId,'^.*\.(\d{1})$','$2');" /> -->
								</xsl:variable>

								<xsl:text>_</xsl:text><xsl:value-of select="$unitIdCount" />

							</xsl:when>
							<xsl:otherwise><xsl:text /></xsl:otherwise>
						</xsl:choose>
					</xsl:variable>
					
					<!-- Here is where we put the named anchor link -->
					<xsl:choose>
						<xsl:when test="$currentComponent/@level='series' or $currentComponent/@level='subseries'">
							<a><xsl:attribute name="name"><xsl:value-of select="$seriesAnchorPrefix" /><xsl:value-of select="$subseriesAnchorPrefix" /></xsl:attribute><xsl:text>  </xsl:text></a>
						</xsl:when>
						<xsl:otherwise>
							<xsl:text />
						</xsl:otherwise>
					</xsl:choose>

					<xsl:if test="$currentComponent/ead:did/ead:unitid[string-length(text()|*)!=0]">
					  <xsl:apply-templates select="$currentComponent/ead:did/ead:unitid"/><xsl:text>: </xsl:text>
					</xsl:if>

					<xsl:for-each select="$currentComponent/ead:did">
						<xsl:call-template name="unittitle-stuff"/>
					</xsl:for-each>
					<!-- Adding text here, otherwise, there isn't any space between the title and the physical description -->
					<xsl:text> </xsl:text>
					<xsl:apply-templates select="$currentComponent/ead:did/ead:physdesc"/>
				</h3>

			</xsl:otherwise>
		</xsl:choose>

	
	<xsl:for-each select="$currentComponent/ead:scopecontent/ead:p | $currentComponent/ead:scopecontent/ead:note/ead:p">
		<p><xsl:apply-templates select="."/></p>
	</xsl:for-each>

	<!-- Call the subseries-list template -->
	<xsl:call-template name="subseries-list" />

</xsl:template>



<xsl:template name="generateAnchorString">	
	<!-- Determine the anchor prefix -->
	<!-- Creates a link that points to the series -->
	<xsl:variable name="level1Count">
		<xsl:number count="ead:dsc/ead:c" from="ead:dsc"/>
	</xsl:variable>
	<xsl:variable name="seriesAnchorPrefix">
		<xsl:value-of select="concat('series',string($level1Count))" />
		<xsl:variable name="levelCount">
			<xsl:number count="ead:dsc/ead:c/ead:c" from="ead:dsc/ead:c/ead:c"/>
		</xsl:variable>
		<xsl:if test="number($levelCount)">
			<xsl:value-of select="concat('_',string($levelCount))" />			
		</xsl:if>
	</xsl:variable>

	<xsl:value-of select="$seriesAnchorPrefix" />
</xsl:template>


<!-- A "function" for determining whether the current component is a series or not -->
<xsl:template name="checkForSeries">
	<xsl:param name="currentComponent" />
	<xsl:choose>
		<xsl:when test="$currentComponent/@level!='' or $currentComponent/@otherlevel!=''"> 
			<xsl:text>true</xsl:text>
		</xsl:when>
		<xsl:otherwise>
			<xsl:text>false</xsl:text>
		</xsl:otherwise>
	</xsl:choose>
</xsl:template>

<!-- A "function" for determining whether the current component is a series or not -->
<xsl:template name="checkForFolderGroup">
	<xsl:param name="currentComponent" />
	<xsl:choose>
		<xsl:when test="$currentComponent/@level!='' or $currentComponent/@otherlevel!=''"> 
			<xsl:text>true</xsl:text>
		</xsl:when>
		<xsl:otherwise>
			<xsl:text>false</xsl:text>
		</xsl:otherwise>
	</xsl:choose>
</xsl:template>

<!-- BY GOR - NEED TO UNDERSTAND THIS -->
<!-- 
	This template attempts to determine the previous container number for the current container type.  This turns out to be very complicated:
	the previous container number, could come from the parent of the current component, from the component's previous sibling, or from a child 
	of that previous sibling, with permutations on this.
	
	The various choices are all outlined below. There are many of them. Each is documented as to why it comes in the order specified 
	
-->
<xsl:template name="determineContainerNumber">
	<xsl:param name="currentComponent" />
	<xsl:param name="componentPosition" />
	<xsl:param name="containerType" />
	
	<xsl:message><xsl:value-of select="$containerType" /></xsl:message>
	<xsl:for-each select="$currentComponent">
		<xsl:choose>
			<!-- If this is the first child of series level component, the previous container number is blank -->
			<xsl:when test="$componentPosition = 1 and (string-length(./parent::node()[@level]) or string-length(./parent::node()[@otherlevel]))">
				<xsl:message><xsl:value-of select="ead:did/ead:unittitle" /><xsl:text>This is the first child of a series component</xsl:text></xsl:message>
				<xsl:text></xsl:text>
			</xsl:when>

			<!-- If this is the first element for its parent component, Get the container number from the parent for this component -->
			<xsl:when test="$componentPosition = 1 and ./parent::node()/ead:did/ead:container[@type=$containerType]">
				<xsl:message><xsl:value-of select="ead:did/ead:unittitle" /><xsl:text>Getting $containerType number from parent</xsl:text></xsl:message>
				<xsl:value-of select="./parent::node()/ead:did/ead:container[@type=$containerType]" />
			</xsl:when>

			<!-- 
				All of the possible previous component possibilities for c06. The order is designed to ensure that the most nested cases are handled first,
				because otherwise they would be overridden by less nested options 
			-->

			<!-- Get the container number from the previous sibling of this c06 -->
			<xsl:when test="./parent::node()/c06[number($componentPosition -1)]/ead:did/ead:container[@type=$containerType]">
				<xsl:message><xsl:value-of select="ead:did/ead:unittitle" /><xsl:text>Getting $containerType number from previous c06 sibling</xsl:text></xsl:message>
				<xsl:value-of select="./parent::node()/ead:c06[number($componentPosition -1)]/ead:did/ead:container[@type=$containerType]" />
			</xsl:when>

			<!-- Get the container number from the previous sibling of the parent of the c05 parent of this c06 -->
			<xsl:when test="./parent::node()/preceding-sibling::c05/ead:did/ead:container[@type=$containerType]">
				<xsl:message><xsl:value-of select="ead:did/ead:unittitle" /><xsl:text>Getting $containerType number from previous parent c05</xsl:text></xsl:message>
				<xsl:value-of select="./parent::node()/preceding-sibling::c05/ead:did/ead:container[@type=$containerType]" />
			</xsl:when>

			<!-- 
				All of the possible previous component possibilities for c05. The order is designed to ensure that the most nested cases are handled first,
				because otherwise they would be overridden by less nested options 
			-->

			<!-- Get the container number from the last c06 child of the previous c05 sibling of this c05 -->
			<xsl:when test="./parent::node()/c05[number($componentPosition -1)]/c06[last()]/ead:did/ead:container[@type=$containerType]">
				<xsl:message><xsl:value-of select="ead:did/ead:unittitle" /><xsl:text>Getting $containerType number from last c06 precedent of previous c04</xsl:text></xsl:message>
				<xsl:value-of select="./parent::node()/c05[number($componentPosition -1)]/c06[last()]/ead:did/ead:container[@type=$containerType]" />
			</xsl:when>

			<!-- Get the container number from the previous sibling of this c05 -->
			<xsl:when test="./parent::node()/c05[number($componentPosition -1)]/ead:did/ead:container[@type=$containerType]">
				<xsl:message><xsl:value-of select="ead:did/ead:unittitle" /><xsl:text>Getting $containerType number from previous c05 sibling</xsl:text></xsl:message>
				<xsl:value-of select="./parent::node()/c05[number($componentPosition -1)]/ead:did/ead:container[@type=$containerType]" />
			</xsl:when>

			<!-- Get the container number from the previous sibling of the parent of the c04 parent of this c05 -->
			<xsl:when test="./parent::node()/preceding-sibling::c04/ead:did/ead:container[@type=$containerType]">
				<xsl:message><xsl:value-of select="ead:did/ead:unittitle" /><xsl:text>Getting $containerType number from previous parent c04</xsl:text></xsl:message>
				<xsl:value-of select="./parent::node()/preceding-sibling::c04/ead:did/ead:container[@type=$containerType]" />
			</xsl:when>

			<!-- 
				All of the possible previous component possibilities for c04. The order is designed to ensure that the most nested cases are handled first,
				because otherwise they would be overridden by less nested options 
			-->

			<!-- Get the container number from the last c06 child of the last c05 child of the previous c04 sibling of this c04 -->
			<xsl:when test="./parent::node()/c04[number($componentPosition -1)]/c05[last()]/c06[last()]/ead:did/ead:container[@type=$containerType]">
				<xsl:message><xsl:value-of select="ead:did/ead:unittitle" /><xsl:text>Getting $containerType number from last c06 precedent of previous c03</xsl:text></xsl:message>
				<xsl:value-of select="./parent::node()/c04[number($componentPosition -1)]/c05[last()]/c06[last()]/ead:did/ead:container[@type=$containerType]" />
			</xsl:when>

			<!-- Get the container number from the last c05 child of the previous c04 sibling of this c04 -->
			<xsl:when test="./parent::node()/c04[number($componentPosition -1)]/c05[last()]/ead:did/ead:container[@type=$containerType]">
				<xsl:message><xsl:value-of select="ead:did/ead:unittitle" /><xsl:text>Getting $containerType number from last c05 precedent of previous c03</xsl:text></xsl:message>
				<xsl:value-of select="./parent::node()/c04[number($componentPosition -1)]/c05[last()]/ead:did/ead:container[@type=$containerType]" />
			</xsl:when>

			<!-- Get the container number from the previous sibling of this c04 -->
			<xsl:when test="./parent::node()/c04[number($componentPosition -1)]/ead:did/ead:container[@type=$containerType]">
				<xsl:message><xsl:value-of select="ead:did/ead:unittitle" /><xsl:text>Getting $containerType number from previous c04 sibling</xsl:text></xsl:message>
				<xsl:value-of select="./parent::node()/c04[number($componentPosition -1)]/ead:did/ead:container[@type=$containerType]" />
			</xsl:when>

			<!-- Get the container number from the previous sibling of the parent of the c03 parent of this c04 -->
			<xsl:when test="./parent::node()/preceding-sibling::c03/ead:did/ead:container[@type=$containerType]">
				<xsl:message><xsl:value-of select="ead:did/ead:unittitle" /><xsl:text>Getting $containerType number from previous parent c03</xsl:text></xsl:message>
				<xsl:value-of select="./parent::node()/preceding-sibling::c03/ead:did/ead:container[@type=$containerType]" />
			</xsl:when>

			<!-- 
				All of the possible previous component possibilities for c03. The order is designed to ensure that the most nested cases are handled first,
				because otherwise they would be overridden by less nested options 
			-->

			<!-- Get the container number from the last c06 child of the last c05 child of the last c04 child of the previous c03 sibling of this c03 -->
			<xsl:when test="./parent::node()/c03[number($componentPosition -1)]/c04[last()]/c05[last()]/c06[last()]/ead:did/ead:container[@type=$containerType]">
				<xsl:message><xsl:value-of select="ead:did/ead:unittitle" /><xsl:text>Getting $containerType number from last c06 precedent of previous c02</xsl:text></xsl:message>
				<xsl:value-of select="./parent::node()/c03[number($componentPosition -1)]/c04[last()]/c05[last()]/c06[last()]/ead:did/ead:container[@type=$containerType]" />
			</xsl:when>

			<!-- Get the container number from the last c05 child of the last c04 child of the previous c03 sibling of this c03 -->
			<xsl:when test="parent::node()/c03[number($componentPosition -1)]/c04[last()]/c05[last()]/ead:did/ead:container[@type=$containerType]">
				<xsl:message><xsl:value-of select="ead:did/ead:unittitle" /><xsl:text>Getting $containerType number from last c05 precedent of previous c02</xsl:text></xsl:message>
				<xsl:value-of select="./parent::node()/c03[number($componentPosition -1)]/c04[last()]/c05[last()]/ead:did/ead:container[@type=$containerType]" />
			</xsl:when>

			<!-- Get the container number from the last c04 child of the previous c03 sibling of this c03 -->
			<xsl:when test="./parent::node()/c03[number($componentPosition -1)]/c04[last()]/ead:did/ead:container[@type=$containerType]">
				<xsl:message><xsl:value-of select="ead:did/ead:unittitle" /><xsl:text>Getting $containerType number from last c04 precedent of previous c02</xsl:text></xsl:message>
				<xsl:value-of select="./parent::node()/c03[number($componentPosition -1)]/c04[last()]/ead:did/ead:container[@type=$containerType]" />
			</xsl:when>

			<!-- Get the container number from the previous sibling of this c03 -->
			<xsl:when test="./parent::node()/c03[number($componentPosition -1)]/ead:did/ead:container[@type=$containerType]">
				<xsl:message><xsl:value-of select="ead:did/ead:unittitle" /><xsl:text>Getting $containerType number from previous c03 sibling</xsl:text></xsl:message>
				<xsl:value-of select="./parent::node()/c03[number($componentPosition -1)]/ead:did/ead:container[@type=$containerType]" />
			</xsl:when>

			<!-- Get the container number from the previous sibling of the parent of the c02 parent of this c03 -->
			<xsl:when test="./parent::node()/preceding-sibling::c02/ead:did/ead:container[@type=$containerType]">
				<xsl:message><xsl:value-of select="ead:did/ead:unittitle" /><xsl:text>Getting $containerType number from previous parent c02</xsl:text></xsl:message>
				<xsl:value-of select="parent::node()/preceding-sibling::c02/ead:did/ead:container[@type=$containerType]" />
			</xsl:when>

			<!-- 
				All of the possible previous component possibilities for c02. The order is designed to ensure that the most nested cases are handled first,
				because otherwise they would be overridden by less nested options 
			-->

			<!-- Get the container number from the last c06 child of the last c05 child of the last c04 child of the last c03 child of the previous sibling of this c02 -->
			<xsl:when test="./parent::node()/c02[number($componentPosition -1)]/c03[last()]/c04[last()]/c05[last()]/c06[last()]/ead:did/ead:container[@type=$containerType]">
				<xsl:message><xsl:value-of select="ead:did/ead:unittitle" /><xsl:text>Getting $containerType number from last c06 precedent of previous c02</xsl:text></xsl:message>
				<xsl:value-of select="./parent::node()/c02[number($componentPosition -1)]/c03[last()]/c04[last()]/c05[last()]/c06[last()]/ead:did/ead:container[@type=$containerType]" />
			</xsl:when>

			<!-- Get the container number from the last c05 child of the last c04 child of the last c03 child of the previous sibling of this c02 -->
			<xsl:when test="./parent::node()/c02[number($componentPosition -1)]/c03[last()]/c04[last()]/c05[last()]/ead:did/ead:container[@type=$containerType]">
				<xsl:message><xsl:value-of select="ead:did/ead:unittitle" /><xsl:text>Getting $containerType number from last c05 precedent of previous c02</xsl:text></xsl:message>
				<xsl:value-of select="./parent::node()/c02[number($componentPosition -1)]/c03[last()]/c04[last()]/c05[last()]/ead:did/ead:container[@type=$containerType]" />
			</xsl:when>

			<!-- Get the container number from the last c04 child of the last c03 child of the previous sibling of this c02 -->
			<xsl:when test="./parent::node()/c02[number($componentPosition -1)]/c03[last()]/c04[last()]/ead:did/ead:container[@type=$containerType]">
				<xsl:message><xsl:value-of select="ead:did/ead:unittitle" /><xsl:text>Getting $containerType number from last c04 precedent of previous c02</xsl:text></xsl:message>
				<xsl:value-of select="./parent::node()/c02[number($componentPosition -1)]/c03[last()]/c04[last()]/ead:did/ead:container[@type=$containerType]" />
			</xsl:when>

			<!-- Get the container number from the last c03 child of the previous sibling of this c02 -->
			<xsl:when test="./parent::node()/c02[number($componentPosition -1)]/c03[last()]/ead:did/ead:container[@type=$containerType]">
				<xsl:message><xsl:value-of select="ead:did/ead:unittitle" /><xsl:text>Getting $containerType number from last c03 precedent of previous c02</xsl:text></xsl:message>
				<xsl:value-of select="./parent::node()/c02[number($componentPosition -1)]/c03[last()]/ead:did/ead:container[@type=$containerType]" />
			</xsl:when>

			<!-- Get the container number from the previous sibling of this c02 -->
			<xsl:when test="./parent::node()/c02[number($componentPosition -1)]/ead:did/ead:container[@type=$containerType]">
				<xsl:message><xsl:value-of select="ead:did/ead:unittitle" /><xsl:text>Getting $containerType number from previous c02 sibling</xsl:text></xsl:message>
				<xsl:value-of select="./parent::node()/c02[number($componentPosition -1)]/ead:did/ead:container[@type=$containerType]" />
			</xsl:when>
			
			<xsl:otherwise>
			</xsl:otherwise>
		</xsl:choose>
	</xsl:for-each>
</xsl:template>

<!-- Displays the biographical statement (not used by our finding aids) or arrangement note -->
<xsl:template match="ead:dsc/ead:c/ead:bioghist | ead:dsc/ead:c/ead:arrangement">		
	<xsl:for-each select="p">
		<p><xsl:apply-templates select="."/></p>
	</xsl:for-each>
</xsl:template>

<!-- Blockquote template -->
<xsl:template match="blockquote">
	<blockquote>
		<p><xsl:apply-templates/></p>
	</blockquote>
</xsl:template>

<!-- The following templates format the display of various RENDER attributes.-->
<xsl:template match="*/title">
	<xsl:apply-templates/>
</xsl:template>

<xsl:template match="*/emph">
	<xsl:apply-templates/>
</xsl:template>

<xsl:template match="*[@render='bold']">
	<b>
		<xsl:apply-templates />
	</b>
</xsl:template>

<xsl:template match="*[@render='italic']">
	<i>
		<xsl:apply-templates />
	</i>
</xsl:template>

<xsl:template match="*[@render='underline']">
	<u>
		<xsl:apply-templates />
	</u>
</xsl:template>

<xsl:template match="*[@render='sub']">
	<sub>
		<xsl:apply-templates />
	</sub>
</xsl:template>

<xsl:template match="*[@render='super']">
	<super>
		<xsl:apply-templates />
	</super>
</xsl:template>

<xsl:template match="*[@render='quoted']">
	<xsl:text>"</xsl:text>
	<xsl:apply-templates />
	<xsl:text>"</xsl:text>
</xsl:template>

<xsl:template match="*[@render='boldquoted']">
	<b>
		<xsl:text>"</xsl:text>
		<xsl:apply-templates />
		<xsl:text>"</xsl:text>
	</b>
</xsl:template>

<xsl:template match="*[@render='boldunderline']">
	<b>
		<u>
			<xsl:apply-templates />
		</u>
	</b>
</xsl:template>

<xsl:template match="*[@render='bolditalic']">
	<b>
		<i>
			<xsl:apply-templates />
		</i>
	</b>
</xsl:template>

<xsl:template match="*[@render='boldsmcaps']">
	<b>
		<xsl:apply-templates />
	</b>
</xsl:template>

<xsl:template match="*[@render='smcaps']">
	<xsl:apply-templates />
</xsl:template>

<!-- This template converts a Ref element into an internal anchor.-->

<xsl:template match="//ref">
	<xsl:variable name="target">
		<xsl:value-of select="@target"/>
	</xsl:variable>
	<a href="#{$target}">
		<xsl:apply-templates />
	</a>
</xsl:template>

<!-- This template converts a ExtRef element into an external anchor.-->

<xsl:template match="//extref">
	<xsl:variable name="href">
		<xsl:value-of select="@href"/>
	</xsl:variable>
	<a href="{$href}">
		<xsl:apply-templates />
	</a>
</xsl:template>
	

	<!-- COMMENTED-OUT BY GOR - need to reevaluate -->
	<!-- Converts an ID attribute into the name attribute of an HTML anchor to form the target of a Ref element.-->
	
<!-- 	<xsl:template match="*[@id]">
		<a name="{@id}">
			<xsl:apply-templates />
		</a>
	</xsl:template> -->
	
	
	<!--Formats a simple table. The width of each column is defined by the colwidth attribute in a colspec element.-->
	<xsl:template match="*/table">
		<xsl:for-each select="tgroup">
			<table width="100%">
				<tr>
					<xsl:for-each select="colspec">
						<td width="{@colwidth}"></td>
					</xsl:for-each>
				</tr>
				<xsl:for-each select="thead">
					<xsl:for-each select="row">
						<tr>
							<xsl:for-each select="entry">
								<td valign="top">
									<b>
										<xsl:apply-templates />
									</b>
								</td>
							</xsl:for-each>
						</tr>
					</xsl:for-each>
				</xsl:for-each>
				
				<xsl:for-each select="tbody">
					<xsl:for-each select="row">
						<tr>
							<xsl:for-each select="entry">
								<td valign="top">
									<xsl:apply-templates />
								</td>
							</xsl:for-each>
						</tr>
					</xsl:for-each>
				</xsl:for-each>
			</table>
		</xsl:for-each>
	</xsl:template>
	
	<!--This template rule formats a chronlist element.-->
	
	<xsl:template match="//ead:chronlist">
		<table width="100%">
			<tr>
				<td width="5%">
				</td>
				<td width="30%">
				</td>
				<td width="65%">
				</td>
			</tr>
			
			<xsl:for-each select="ead:listhead">
				<tr>
					<td>
						<b>
							<xsl:apply-templates select="ead:head01"/>
						</b>
					</td>
					<td>
						<b>
							<xsl:if test="ead:head02[string-length(text()|*)!=0]">
								<xsl:apply-templates select="ead:head02"/>
							</xsl:if>
						</b>
					</td>
				</tr>
			</xsl:for-each>
			
			<xsl:for-each select="ead:chronitem">
				<tr>
					<td valign="top">
						<xsl:apply-templates select="ead:date"/>
					</td>
					<td valign="top">
						<xsl:apply-templates select="ead:event"/>
					</td>
				</tr>
			</xsl:for-each>
		</table>
	</xsl:template>
	
	<!--This template rule formats a list element.-->
	<xsl:template match="//ead:scopecontent/ead:p/ead:list | //odd/ead:p/ead:list">
		<xsl:if test="string-length(ead:head)">
			<h4><xsl:apply-templates select="ead:head"/></h4>
		</xsl:if>
		<dl>
		<xsl:for-each select="ead:item">
			<dd><xsl:apply-templates select="."/></dd>
		</xsl:for-each>				
		</dl>
	</xsl:template>

	<!--This template replaces string(s) within a string -->
	<xsl:template name="replace-string">
	  <xsl:param name="text"/>
	  <xsl:param name="replace"/>
	  <xsl:param name="with"/>
	  <xsl:choose>
	    <xsl:when test="contains($text,$replace)">
	      <xsl:value-of select="substring-before($text,$replace)"/>
	      <xsl:value-of select="$with"/>
	      <xsl:call-template name="replace-string">
	        <xsl:with-param name="text" select="substring-after($text,$replace)"/>
	        <xsl:with-param name="replace" select="$replace"/>
	        <xsl:with-param name="with" select="$with"/>
	      </xsl:call-template>
	    </xsl:when>
	    <xsl:otherwise>
	      <xsl:value-of select="$text"/>
	    </xsl:otherwise>
	  </xsl:choose>
	</xsl:template>

</xsl:stylesheet>